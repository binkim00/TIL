####################################################
# [문제]
# N개의 상자가 일렬로 놓여 있다.
# 각 상자에서 오른쪽에 있는 더 낮은 상자의 개수를 구할 때,
# 가장 큰 낙차를 출력하시오.
# 배열 안의 최대값 − 최소값 구하기 문제
#
# [입력 예시]
# 1
# 6
# 4 3 2 1 3 2
#
# [출력 예시]
# #1 3
####################################################

T = int(input())  # 테스트 케이스 개수 입력

for test_case in range(1, T + 1):  # 1번 케이스부터 T번 케이스까지 반복
    N = int(input())  # 상자(기둥) 개수
    boxes = list(map(int, input().split()))  # 상자 높이 리스트

    max_drop = 0  # 전체 상자들 중 "가장 큰 낙차(낮은 상자 개수)"를 저장

    # i는 "현재 상자의 위치(인덱스)"
    # 마지막 상자(N-1)는 오른쪽이 없으므로 비교할 필요가 없어 N-1까지만
    for i in range(N - 1):

        drop_count = 0  # i번째 상자의 낙차(오른쪽에 더 낮은 상자 개수)

        # j는 "오른쪽에 있는 상자의 위치(인덱스)"
        # i 바로 오른쪽(i+1)부터 끝(N-1)까지 비교
        for j in range(i + 1, N):

            # 현재 상자(boxes[i])가 오른쪽 상자(boxes[j])보다 높으면
            # 오른쪽 상자는 "더 낮은 상자"이므로 낙차 1 증가
            if boxes[i] > boxes[j]:
                drop_count += 1

        # i번째 상자의 낙차가 지금까지의 최대 낙차보다 크면 갱신
        if drop_count > max_drop:
            max_drop = drop_count

    print(f"#{test_case} {max_drop}")
