####################################################
# [상자 문제 3번 : 낙차 (Gravity)]
#
# [문제]
# N개의 상자가 일렬로 놓여 있다.
# 각 상자의 높이가 주어진다.
#
# 각 상자에 대해,
# 자기보다 오른쪽에 있으면서 "더 낮은 상자"의 개수를 센다.
#
# 이때,
# 각 상자에서 센 개수들 중
# 가장 큰 값을 출력하시오.
#
# (즉, 가장 많이 떨어질 수 있는 상자의 낙차를 구하는 문제)
#
# --------------------------------------------------
# [입력 예시 1]
# 9
# 7 4 2 0 0 6 0 7 0
#
# [출력 예시 1]
# 7
#
# --------------------------------------------------
# [입력 예시 2]
# 9
# 4 2 0 0 7 6 0 7 0
#
# [출력 예시 2]
# 5
####################################################

N = int(input())                      # 상자의 개수
boxes = list(map(int, input().split()))  # 각 상자의 높이

max_drop = 0  # 전체 상자 중 가장 큰 낙차를 저장할 변수

# i : 기준이 되는 상자의 위치(인덱스)
# 마지막 상자는 오른쪽에 상자가 없으므로 N-1까지만 검사
for i in range(N - 1):

    drop_count = 0
    # drop_count : i번째 상자 기준,
    # 오른쪽에 있으면서 더 낮은 상자의 개수(낙차)

    # j : i번째 상자의 오른쪽에 있는 상자들의 위치
    for j in range(i + 1, N):

        # 기준 상자(boxes[i])가
        # 오른쪽 상자(boxes[j])보다 높으면
        # 떨어질 수 있으므로 낙차 +1
        if boxes[i] > boxes[j]:
            drop_count += 1

    # 현재 상자의 낙차가
    # 지금까지 구한 최대 낙차보다 크면 갱신
    if drop_count > max_drop:
        max_drop = drop_count

# 가장 큰 낙차 출력
print(max_drop)
