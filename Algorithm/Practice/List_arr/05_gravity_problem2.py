####################################################
# [문제]
# N개의 상자가 일렬로 놓여 있다.
# 각 상자의 높이가 주어진다.
#
# 각 상자에 대해,
# 자기보다 오른쪽에 있으면서 "더 낮은 상자"의 개수를 센다.
# 이때, 가장 큰 낙차(더 낮은 상자 개수)를 출력하시오.
# 기준 상자 하나 정하고 오른쪽만 본다.
# 나보다 낮은 상자의 개수, 그 개수 중 최댓값
#
# [입력 예시]
# 9
# 7 4 2 0 0 6 0 7 0
#
# [출력 예시]
# 7
#
# [입력 예시]
# 9
# 4 2 0 0 7 6 0 7 0
#
# [출력 예시]
# 5
####################################################

N = int(input())                     # 상자 개수
boxes = list(map(int, input().split()))  # 상자 높이 리스트

max_drop = 0  # 전체 상자 중 가장 큰 낙차를 저장

# i는 "기준이 되는 상자의 위치"
# 마지막 상자는 오른쪽에 비교 대상이 없으므로 N-1까지만 확인
for i in range(N - 1):

    drop_count = 0  # i번째 상자의 낙차 (오른쪽에 있는 더 낮은 상자 개수)

    # j는 i번째 상자의 오른쪽에 있는 상자들
    for j in range(i + 1, N):

        # 기준 상자가 오른쪽 상자보다 높으면
        # 낙차가 1 증가
        if boxes[i] > boxes[j]:
            drop_count += 1

    # 현재 상자의 낙차가 지금까지의 최대 낙차보다 크면 갱신
    if drop_count > max_drop:
        max_drop = drop_count

# 가장 큰 낙차 출력
print(max_drop)
