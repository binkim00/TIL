"""
시간 복잡도(Time Complexity) 정리 파일

============================================================
1️⃣ 시간 복잡도란?
------------------------------------------------------------
- "입력 데이터의 크기(N)가 증가할 때,
  알고리즘의 실행 시간이 얼마나 증가하는가"를 나타내는 개념
- 실제 시간(초)을 재는 것이 아니라,
  '연산 횟수의 증가 추세'를 기준으로 판단한다.

✔ 핵심 포인트
- 컴퓨터 성능, 언어, 환경과 무관하게 알고리즘을 비교하기 위함
- 가장 영향력이 큰 연산만 고려한다.

============================================================
2️⃣ Big-O 표기법 (빅오 표기법)
------------------------------------------------------------
- 시간 복잡도를 표현하는 표준 방식
- 최악의 경우(Worst Case)를 기준으로 한다.

자주 쓰는 Big-O 정리:

O(1)     : 입력 크기와 무관 (상수 시간)
O(log N) : 로그 시간
O(N)     : 선형 시간
O(N log N)
O(N^2)   : 제곱 시간
O(2^N), O(N!) : 매우 느림 (실무에서 거의 사용 불가)

============================================================
3️⃣ 예제로 이해하는 시간 복잡도
------------------------------------------------------------
"""


def example_o1(arr):
    """
    O(1) - 상수 시간
    - 배열 크기와 상관없이 한 번만 실행
    """
    return arr[0]


def example_on(arr):
    """
    O(N) - 선형 시간
    - 배열 길이만큼 반복
    """
    total = 0
    for x in arr:
        total += x
    return total


def example_on2(arr):
    """
    O(N^2) - 이중 반복문
    - N이 커질수록 실행 시간이 급격히 증가
    """
    count = 0
    for i in arr:
        for j in arr:
            count += 1
    return count


"""
============================================================
4️⃣ 반복문으로 시간 복잡도 판단하는 법
------------------------------------------------------------

✔ 반복문 1개
for i in range(N):
    ...
→ O(N)

✔ 반복문 2개 (중첩)
for i in range(N):
    for j in range(N):
        ...
→ O(N^2)

✔ 반복문이 순차적으로 나옴
for i in range(N):
    ...
for j in range(N):
    ...
→ O(N + N) = O(N)

✔ 반복문 범위가 줄어들어도
for i in range(N):
    for j in range(i):
        ...
→ 대략 N*(N-1)/2 → O(N^2)

============================================================
5️⃣ 버블 정렬의 시간 복잡도 분석
------------------------------------------------------------

버블 정렬 구조:

for end in range(N-1, 0, -1):   # 약 N번
    for j in range(end):        # 평균적으로 N번
        비교 및 교환

✔ 전체 비교 횟수
- (N-1) + (N-2) + ... + 1
- 약 N^2 / 2

✔ 시간 복잡도
- 최악: O(N^2)
- 평균: O(N^2)
- 최선(최적화 없는 경우): O(N^2)

👉 그래서 버블 정렬은
- 이해하기 쉽다 ✅
- 구현이 간단하다 ✅
- 하지만 데이터가 많아지면 매우 느리다 ❌

============================================================
6️⃣ 왜 Big-O에서는 상수는 무시할까?
------------------------------------------------------------

예)
N^2 + 3N + 10  →  O(N^2)

이유:
- N이 커질수록 N^2의 영향력이 압도적으로 커짐
- 상수나 작은 항은 성장률에 큰 의미가 없음

============================================================
7️⃣ 정리 한 줄 요약
------------------------------------------------------------
- 시간 복잡도는 "얼마나 빠르냐"가 아니라
  "입력이 커질수록 얼마나 느려지냐"를 본다.
- 반복문 개수와 중첩 구조를 보면 대부분 판단 가능
- 버블 정렬은 대표적인 O(N^2) 알고리즘
============================================================
"""


# ----------------- 간단 테스트 -----------------
if __name__ == "__main__":
    data = [1, 2, 3, 4, 5]

    print("O(1):", example_o1(data))
    print("O(N):", example_on(data))
    print("O(N^2):", example_on2(data))
