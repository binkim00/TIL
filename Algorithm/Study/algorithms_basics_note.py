# -*- coding: utf-8 -*-
"""
알고리즘 기초 개념 정리 (정렬 · 완전검색 · 탐욕 · 순열)
- 목적: 문제 풀기 전에 "어떤 알고리즘을 떠올려야 하는지" 감을 잡기 위한 노트
- 형태: 주석(설명) + 아주 작은 예시 코드(필요 최소)
"""

###############################################################################
# 0) 빠른 선택 기준 (문제 단서 → 떠올릴 것)
###############################################################################
# - "인접한 두 값 비교해서 swap" → 버블 정렬
# - "값의 범위가 작다(0~9, 1~100 등)" → 카운팅 정렬
# - "가능한 경우를 전부 확인" → 완전 검색(브루트포스)
# - "최소/최대 횟수, 지금 가장 좋은 선택 반복" → 탐욕(Greedy)
# - "순서가 중요, 모든 순서 시도" → 순열(Permutation)

###############################################################################
# 1) 버블 정렬 (Bubble Sort)
###############################################################################
# [개념]
# - 인접한 두 원소를 비교해서 큰 값을 뒤로 보내는 정렬
# - 한 바퀴(패스)를 끝내면 "가장 큰 값"이 맨 뒤로 확정됨
#
# [핵심 아이디어]
# - i번 자리에 올 값을 확정시키는 방식으로 범위를 줄여감
#
# [특징]
# - 시간복잡도: O(N^2)  (N이 커지면 느림)
# - 구현이 쉬워서 "정렬 원리 이해용"으로 자주 등장
#
# [언제 떠올리나?]
# - 정렬 알고리즘을 직접 구현하라고 요구할 때(시험/수업)
# - 인접 비교/교환 구조가 보일 때
#
# [슈도코드]
# for end from N-1 down to 1:
#     for j from 0 to end-1:
#         if a[j] > a[j+1]:
#             swap(a[j], a[j+1])

def bubble_sort(arr):
    """버블정렬: 리스트 arr를 오름차순으로 제자리 정렬한다."""
    n = len(arr)
    for end in range(n - 1, 0, -1):      # end: 이번 패스에서 마지막 비교 인덱스
        for j in range(end):             # j와 j+1 비교
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]


###############################################################################
# 2) 카운팅 정렬 (Counting Sort)
###############################################################################
# [개념]
# - 값 비교로 정렬하는 것이 아니라, "각 값이 몇 번 등장했는지" 세어서 정렬
# - 값의 범위가 작고(=최댓값이 크지 않고), 정수일 때 매우 강력
#
# [핵심 아이디어]
# - count[x] = x가 나온 횟수
# - count를 앞에서부터 읽으며 결과를 만든다
#
# [특징]
# - 시간복잡도: O(N + K)  (K = 값의 범위 크기)
# - 값의 범위(K)가 너무 크면 메모리/시간이 부담됨
#
# [언제 떠올리나?]
# - "0~9", "1~100" 같이 범위가 명확히 제한된 문제
# - 카드 최빈값, 점수 집계 같은 빈도 문제

def counting_sort(arr, max_value):
    """
    카운팅 정렬(오름차순):
    - arr: 정렬할 정수 리스트
    - max_value: arr의 최댓값(값의 범위를 알 때 넣음)
    반환: 정렬된 새 리스트
    """
    count = [0] * (max_value + 1)

    # 1) 개수 세기
    for x in arr:
        count[x] += 1

    # 2) 개수대로 결과 만들기
    result = []
    for value in range(max_value + 1):
        for _ in range(count[value]):
            result.append(value)

    return result


###############################################################################
# 3) 완전 검색 (Brute Force / 완전탐색)
###############################################################################
# [개념]
# - 가능한 모든 경우를 하나도 빠짐없이 전부 확인하는 방법
#
# [핵심 아이디어]
# - "다 해보면 정답은 반드시 있다"
# - 대신 경우의 수가 커지면 시간 초과 위험
#
# [특징]
# - 구현은 쉬운 편
# - 입력 크기(N)가 작을 때만 현실적으로 가능
#
# [언제 떠올리나?]
# - N이 작다는 조건이 있을 때
# - 다른 최적화 아이디어가 안 떠오를 때, 먼저 정답 검증용으로 사용

def brute_force_max_pair_sum(arr):
    """
    예시(완전탐색):
    - 모든 i<j 쌍을 다 확인해서 두 수의 합 최대값을 찾는다.
    - 시간복잡도: O(N^2)
    """
    n = len(arr)
    best = None
    for i in range(n):
        for j in range(i + 1, n):
            s = arr[i] + arr[j]
            if best is None or s > best:
                best = s
    return best


###############################################################################
# 4) 탐욕 알고리즘 (Greedy)
###############################################################################
# [개념]
# - 매 순간 "지금 당장 가장 좋아 보이는 선택"을 하는 알고리즘
#
# [핵심 아이디어]
# - '지금의 최선'을 반복하면 전체도 최선이 되는 문제들이 있다.
# - 하지만 모든 문제에서 정답을 보장하지는 않는다.
#
# [특징]
# - 빠르게 풀 수 있음(보통 구현도 간단)
# - 정답 보장 여부는 문제의 구조에 달려 있음
#
# [언제 떠올리나?]
# - "최소 횟수 / 최대 효율" 같은 표현
# - "지금 갈 수 있는 것 중 가장 멀리/가장 큰 것" 같은 선택 반복
#
# [대표 예시]
# - 전기버스: 현재 위치에서 K 범위 내 충전소 중 가장 먼 곳으로 이동

def greedy_electric_bus(K, N, chargers):
    """
    전기버스(그리디) 예시:
    - K: 한 번 충전으로 갈 수 있는 최대 거리(정류장 수)
    - N: 종점 번호
    - chargers: 충전소가 있는 정류장 번호 리스트
    반환: 최소 충전 횟수(도착 불가면 0)

    아이디어:
    - 현재 위치 point에서 [point+1 .. point+K] 중
      충전소가 있는 곳을 "가장 멀리" 선택
    """
    charge = [0] * (N + 1)
    for c in chargers:
        charge[c] = 1

    point = 0
    count = 0

    while True:
        if point + K >= N:
            return count

        next_point = -1
        # K 범위 안에서 뒤에서부터 찾으면 "가장 먼 충전소"를 빠르게 찾는다.
        for far in range(K, 0, -1):
            if point + far <= N and charge[point + far] == 1:
                next_point = point + far
                break

        if next_point == -1:
            return 0

        point = next_point
        count += 1


###############################################################################
# 5) 순열 (Permutation)
###############################################################################
# [개념]
# - 원소의 "순서"를 고려한 모든 경우의 수
#   예) [1,2,3] → 123, 132, 213, 231, 312, 321
#
# [특징]
# - 경우의 수: N! (팩토리얼) → N이 조금만 커져도 폭발적으로 증가
# - 보통 N이 작을 때만 사용 가능
#
# [언제 떠올리나?]
# - "모든 순서를 다 해봐야 한다"
# - 배치/순서/조합 시도 문제
#
# [구현 관점]
# - 재귀(백트래킹)로 자주 구현
# - used 배열(방문 체크) + path(현재까지 만든 순열)

def permutations(nums):
    """
    nums의 모든 순열을 리스트로 반환 (백트래킹)
    - 학습용: N이 작을 때만 사용
    """
    n = len(nums)
    used = [0] * n
    path = []
    result = []

    def backtrack():
        if len(path) == n:
            result.append(path[:])
            return

        for i in range(n):
            if used[i] == 1:
                continue
            used[i] = 1
            path.append(nums[i])

            backtrack()

            path.pop()
            used[i] = 0

    backtrack()
    return result


###############################################################################
# 6) 간단 테스트(원하면 실행해보기)
###############################################################################
if __name__ == "__main__":
    # 버블정렬
    a = [55, 7, 78, 12, 42]
    bubble_sort(a)
    print("bubble_sort:", a)  # [7, 12, 42, 55, 78]

    # 카운팅정렬
    b = [3, 1, 2, 3, 0, 2, 3]
    print("counting_sort:", counting_sort(b, max_value=3))  # [0, 1, 2, 2, 3, 3, 3]

    # 완전탐색
    c = [1, 9, 2, 8]
    print("brute_force_max_pair_sum:", brute_force_max_pair_sum(c))  # 17

    # 탐욕(전기버스) 예시
    print("greedy_electric_bus:", greedy_electric_bus(K=3, N=10, chargers=[1, 3, 5, 7, 9]))

    # 순열
    print("permutations([1,2,3]) count:", len(permutations([1, 2, 3])))  # 6
