# -*- coding: utf-8 -*-
############################################################
# 2차원 배열 + 델타(Delta) + 전치/회전 + 순회 패턴 "한 파일 정리"
# (SWEA/백준 실습용)
#
# 목표: 2차원 배열 문제 풀 때 자주 쓰는 개념을 한 번에 정리한다.
# - 입력/생성/순회/출력
# - 얕은 복사 함정
# - 행 우선/열 우선/지그재그
# - 델타(상하좌우/대각선) + 범위 체크
# - 델타 K칸 확장
# - 전치(Transpose) / 대각선 대칭 / 90도 회전
# - 테두리(외곽) 처리
# - (추가) 부분집합(Subset) 비트마스크: 같은 수업 흐름에서 자주 같이 나와서 포함
#
# 주의:
# - 내장함수 max/min/sum 같은 거 없이도 풀 수 있도록, 반복문 패턴 중심으로 적음.
############################################################


############################################################
# 0) 2차원 배열 기본 용어
############################################################
# arr[i][j]
#  - i: 행(row) 인덱스
#  - j: 열(column) 인덱스
#
# 크기
#  - N = len(arr)        # 행 개수
#  - M = len(arr[0])     # 열 개수 (빈 배열이면 주의)
############################################################


############################################################
# 1) 입력 받기 패턴
############################################################

# (1) N x N
# N = int(input())
# arr = [list(map(int, input().split())) for _ in range(N)]

# (2) N x M
# N, M = map(int, input().split())
# arr = [list(map(int, input().split())) for _ in range(N)]

# (3) 공백 없이 들어오는 숫자 문자열 (예: 1234)
# line = input().strip()
# row = list(map(int, line))   # split() 없이 한 글자씩 int 변환


############################################################
# 2) 0으로 채운 보드 만들기 + 얕은 복사 함정
############################################################

# (O) 올바른 방법: 각 행이 서로 다른 리스트
# board = [[0] * M for _ in range(N)]

# (X) 얕은 복사: 같은 행 리스트 "주소"를 N번 복사함
# board = [[0] * M] * N
# board[0][0] = 1 하면, 모든 행의 [0][0]이 같이 바뀜


############################################################
# 3) 2차원 배열 순회 기본 패턴
############################################################

# (1) 행 우선(row-major) 순회
# for i in range(N):
#     for j in range(M):
#         use(arr[i][j])

# (2) 열 우선(col-major) 순회
# for j in range(M):
#     for i in range(N):
#         use(arr[i][j])

# (3) 행 단위 순회 (행 리스트 자체를 자주 씀)
# for row in arr:
#     use(row)

# (4) 출력
# for row in arr:
#     print(*row)   # 언팩 출력


############################################################
# 4) 누적 합 / 최댓값(최솟값) 갱신 "기본 뼈대"
############################################################

# (1) 전체 합
# total = 0
# for i in range(N):
#     for j in range(M):
#         total += arr[i][j]

# (2) 행 합 최댓값
# best = -10**18
# for i in range(N):
#     s = 0
#     for j in range(M):
#         s += arr[i][j]
#     if s > best:
#         best = s

# (3) 열 합 최댓값
# best = -10**18
# for j in range(M):
#     s = 0
#     for i in range(N):
#         s += arr[i][j]
#     if s > best:
#         best = s


############################################################
# 5) 지그재그 순회(→ ← → ←)
############################################################
# i가 짝수면 왼->오
# i가 홀수면 오->왼

# (1) if 방식
# for i in range(N):
#     if i % 2 == 0:
#         for j in range(M):
#             use(arr[i][j])
#     else:
#         for j in range(M - 1, -1, -1):
#             use(arr[i][j])

# (2) 수식 방식 (익숙해지면 빠름)
# for i in range(N):
#     for j in range(M):
#         jj = j if i % 2 == 0 else (M - 1 - j)
#         use(arr[i][jj])


############################################################
# 6) 델타(Delta) 탐색: 상하좌우 / 대각선
############################################################
# 핵심:
# - 방향 벡터(di, dj)로 이웃 좌표를 만든다
# - 범위 체크(0 <= ni < N, 0 <= nj < M) 필수

# (1) 상하좌우 4방향
di4 = [-1, 1, 0, 0]
dj4 = [0, 0, -1, 1]

# (2) 대각선 4방향
di_diag = [-1, -1, 1, 1]
dj_diag = [-1,  1, -1, 1]

# (3) 8방향(상하좌우 + 대각선)
di8 = [-1, -1, -1,  0, 0,  1, 1, 1]
dj8 = [-1,  0,  1, -1, 1, -1, 0, 1]


############################################################
# 7) 델타 기본 예시: (i, j) 기준 상하좌우 1칸 합
############################################################
# best = -10**18
# for i in range(N):
#     for j in range(M):
#         s = arr[i][j]   # 자기 자신 포함
#         for d in range(4):
#             ni = i + di4[d]
#             nj = j + dj4[d]
#             if 0 <= ni < N and 0 <= nj < M:
#                 s += arr[ni][nj]
#         if s > best:
#             best = s


############################################################
# 8) 델타 확장: K칸(1~K)까지 십자 합
############################################################
# best = -10**18
# for i in range(N):
#     for j in range(M):
#         s = arr[i][j]
#         for d in range(4):
#             for c in range(1, K + 1):
#                 ni = i + di4[d] * c
#                 nj = j + dj4[d] * c
#                 if 0 <= ni < N and 0 <= nj < M:
#                     s += arr[ni][nj]
#         if s > best:
#             best = s


############################################################
# 9) 테두리(외곽)만 합 구하기 (N=1 또는 M=1 주의)
############################################################
# 아이디어:
# - N==1 이면 첫 행만 합
# - M==1 이면 첫 열만 합
# - 그 외:
#   (위쪽 행) + (아래쪽 행) + (중간 행들의 왼/오 열)
#
# total = 0
# if N == 1:
#     for j in range(M):
#         total += arr[0][j]
# elif M == 1:
#     for i in range(N):
#         total += arr[i][0]
# else:
#     # 위쪽
#     for j in range(M):
#         total += arr[0][j]
#     # 아래쪽
#     for j in range(M):
#         total += arr[N-1][j]
#     # 중간 행들의 왼/오
#     for i in range(1, N-1):
#         total += arr[i][0]
#         total += arr[i][M-1]


############################################################
# 10) "봉우리(피크) 개수" 같은 델타 응용
############################################################
# 정의 예시:
# - arr[i][j]가 상하좌우(4방향) 이웃들보다 "엄격히 크면" 봉우리
#
# count = 0
# for i in range(N):
#     for j in range(M):
#         is_peak = True
#         for d in range(4):
#             ni = i + di4[d]
#             nj = j + dj4[d]
#             if 0 <= ni < N and 0 <= nj < M:
#                 if arr[i][j] <= arr[ni][nj]:
#                     is_peak = False
#                     break
#         if is_peak:
#             count += 1


############################################################
# 11) 전치(Transpose) / 대각선 대칭 / 90도 회전
############################################################
# 전치: (N x M) -> (M x N)
# transpose[j][i] = arr[i][j]

def transpose_new(arr):
    """새 배열을 만들어 전치 반환 (내장함수 없이)"""
    N = len(arr)
    M = len(arr[0])
    t = [[0] * N for _ in range(M)]
    for i in range(N):
        for j in range(M):
            t[j][i] = arr[i][j]
    return t


def transpose_inplace_square(arr):
    """정사각형(NxN)일 때, 제자리 전치(주대각선 대칭)"""
    N = len(arr)
    for i in range(N):
        for j in range(i + 1, N):
            arr[i][j], arr[j][i] = arr[j][i], arr[i][j]


def mirror_secondary_diagonal_inplace(arr):
    """정사각형(NxN)일 때, 부대각선(↙︎↗︎) 기준 대칭"""
    N = len(arr)
    for i in range(N):
        for j in range(N - i - 1):
            arr[i][j], arr[N-1-j][N-1-i] = arr[N-1-j][N-1-i], arr[i][j]


def rotate_90_cw_inplace(arr):
    """정사각형(NxN) 90도 시계 회전: 전치 + 각 행 뒤집기"""
    N = len(arr)
    # 1) 전치
    for i in range(N):
        for j in range(i + 1, N):
            arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
    # 2) 각 행 뒤집기 (reverse는 메서드지만 시험에서 보통 허용됨)
    # 내장함수 없이 하려면 투포인터로 swap하면 됨.
    for i in range(N):
        left = 0
        right = N - 1
        while left < right:
            arr[i][left], arr[i][right] = arr[i][right], arr[i][left]
            left += 1
            right -= 1


def rotate_90_ccw_inplace(arr):
    """정사각형(NxN) 90도 반시계 회전: 전치 + 위아래 뒤집기"""
    N = len(arr)
    # 1) 전치
    for i in range(N):
        for j in range(i + 1, N):
            arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
    # 2) 위아래 뒤집기 (행 swap)
    top = 0
    bottom = N - 1
    while top < bottom:
        arr[top], arr[bottom] = arr[bottom], arr[top]
        top += 1
        bottom -= 1


############################################################
# 12) (추가) 부분집합(Subset) 비트마스크 정리
############################################################
# 리스트 arr의 부분집합 개수 = 2^N = (1 << N)
# mask의 i번째 비트가 1이면 arr[i]를 선택한 것.
#
# 포함 여부 확인:
#   if mask & (1 << i):
#       선택됨

def subset_sums(arr):
    """모든 부분집합 합을 리스트로 반환 (연습용, N이 작을 때만)"""
    N = len(arr)
    sums = []
    for mask in range(1 << N):
        total = 0
        for i in range(N):
            if mask & (1 << i):
                total += arr[i]
        sums.append(total)
    return sums


############################################################
# 13) 시험장에서 실수 많이 나는 포인트 체크리스트
############################################################
# [2차원]
# 1) board 만들 때 [[0]*M]*N 쓰지 말기 (얕은 복사)
# 2) N, M 바뀌면 순회 순서/범위 다시 확인
# 3) 출력 포맷: '#tc 답' 빠뜨리지 말기
#
# [델타]
# 4) ni, nj 계산 후 범위 체크 반드시
# 5) (i,j)마다 합(s)을 0 또는 arr[i][j]로 "초기화"했는지 확인
# 6) K칸 확장이면 *c 빼먹지 않기 (ni = i + di[d]*c)
#
# [전치/회전]
# 7) 전치는 (N,M) -> (M,N) 크기 바뀜
# 8) 제자리 전치/회전은 "정사각형"만 가능
#
# [부분집합]
# 9) 바깥 loop: range(1<<N)
# 10) 포함 확인: mask & (1<<i)
############################################################


############################################################
# 14) 미니 템플릿 (SWEA 스타일)
############################################################
# T = int(input())
# for tc in range(1, T + 1):
#     N, M = map(int, input().split())
#     arr = [list(map(int, input().split())) for _ in range(N)]
#
#     # 문제 로직
#
#     print(f"#{tc} {answer}")
############################################################
