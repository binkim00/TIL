"""
버블 정렬(Bubble Sort) 정리 파일

✅ 핵심 아이디어
- "인접한 두 원소"를 비교해서, 순서가 잘못되어 있으면 서로 교환(swap)한다.
- 한 바퀴(패스, pass)를 끝내면 "가장 큰 값"이 맨 뒤로 이동한다.
  (큰 값이 거품처럼 뒤로 떠오른다고 해서 Bubble Sort라는 이름이 붙음)

✅ 동작 예시(오름차순)
a = [5, 3, 4, 1]

1번째 패스(끝까지 비교):
(5,3) 교환 -> [3,5,4,1]
(5,4) 교환 -> [3,4,5,1]
(5,1) 교환 -> [3,4,1,5]   # 가장 큰 값 5가 맨 뒤로 감

2번째 패스(마지막은 이미 5로 확정이므로 그 앞까지만 비교):
(3,4) 그대로
(4,1) 교환 -> [3,1,4,5]

3번째 패스:
(3,1) 교환 -> [1,3,4,5]   # 완료

✅ 시간 복잡도
- 평균/최악: O(N^2)
- 이미 정렬이 잘 되어있어도(최적화 없으면) 기본은 O(N^2)

✅ 공간 복잡도
- 추가 배열을 만들지 않는 제자리 정렬(in-place): O(1)

------------------------------------------------------------
버블 정렬 슈도 코드(Pseudo Code) - 오름차순 기준

bubble_sort(A):
    for end from len(A)-1 down to 1:
        for j from 0 up to end-1:
            if A[j] > A[j+1]:
                swap(A[j], A[j+1])

의미:
- end는 "이번 패스에서 비교를 끝낼 마지막 인덱스"
- 패스를 한 번 돌 때마다, 맨 뒤 원소 하나가 확정되므로 end가 줄어듦
------------------------------------------------------------
"""


def bubble_sort(a):
    """
    버블 정렬 (오름차순)
    - a: 정렬할 리스트
    - 반환값: 없음 (리스트 a 자체가 정렬됨: in-place)
    """

    # N: 원소 개수
    N = len(a)

    # end는 "이번 패스에서 마지막 비교 위치"를 의미
    # 예) N=5면 end는 4 -> 3 -> 2 -> 1 순서로 줄어든다.
    # 왜 줄어드냐?
    # - 한 패스가 끝나면 가장 큰 값이 a[end] 위치에 확정되기 때문
    for end in range(N - 1, 0, -1):

        # j는 인접한 두 값을 비교할 때 왼쪽 인덱스
        # 비교는 (a[j], a[j+1]) 형태로 진행한다.
        # j는 0부터 end-1까지 간다. (j+1이 end까지 도달하도록)
        for j in range(0, end):

            # 오름차순 정렬이므로,
            # 왼쪽 값이 오른쪽 값보다 크면 순서가 잘못된 것 -> 교환
            if a[j] > a[j + 1]:
                # 파이썬의 튜플 스왑(swap) 문법
                a[j], a[j + 1] = a[j + 1], a[j]


# ----------------- 테스트 코드 -----------------
if __name__ == "__main__":
    arr = [5, 3, 4, 1, 2]
    print("정렬 전:", arr)

    bubble_sort(arr)

    print("정렬 후:", arr)
