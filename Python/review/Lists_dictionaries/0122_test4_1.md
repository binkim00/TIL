## 🧪 테스트 4-2 — 채점 및 보정

---

### ❓ 질문 1

코드 A 실행 이후 딕셔너리 `user`의 최종 값은 무엇인가?

```python
user = {
"name":"kim",
"age":20
}

defupdate_age(info):
	info["age"] =21

update_age(user)
print(user)

```

### ✅ 답변

> 21
> 

❌ **오답 (부분 값만 답함)**

### 📌 정확한 정리

👉 출력되는 것은 **딕셔너리 전체**이다.

```python
{'name':'kim','age':21}

```

---

### ❓ 질문 2

함수 `update_age` 안의 `info`는

`user`와 같은 객체인가, 다른 객체인가?

### ✅ 답변

> 같은 객체?(info 자리에 user가 들어감)
> 

✔ **정답**

👉 딕셔너리는 함수 인자로 전달될 때 **같은 객체를 참조**한다.

---

### ❓ 질문 3

코드 A에서 `user`가 변경된 이유를

“함수 + 딕셔너리” 관점에서 한 문장으로 설명하시오.

### ✅ 답변

> update_age 함수안에서 user 객체의 딕셔너리 중 age key의 value값인 20을 21로 변환
> 

✔ **정답 (표현만 약간 정리)**

### 📌 정확한 정리

```python
defupdate_age(info):
	info["age"] =21

```

👉 함수에 전달된 딕셔너리는 **같은 객체**이므로

`info["age"] = 21`은 원본 `user` 딕셔너리를 직접 수정한다.

---

### ❓ 질문 4

코드 B 실행 이후 딕셔너리 `user`의 값은 무엇인가?

```python
user = {
"name":"kim",
"age":20
}

defupdate_age(info):
	info = {
"name":"kim",
"age":21
	}

update_age(user)
print(user)

```

### ✅ 답변

> name은 그대로이고(보이는 것만) age만 변경됨, 새로운 값을 할당하는 것
> 

❌ **오답**

### 📌 정확한 정리

👉 출력 결과는 **변경되지 않는다**.

```python
{'name':'kim','age':20}

```

```python
defupdate_age(info):
	info = {
"name":"kim",
"age":21
	}

```

👉 이 코드는

- 새로운 딕셔너리를 만들고
- 그 딕셔너리를 **지역 변수 `info`에 재할당**할 뿐
    
    원본 `user`와는 연결되지 않는다.
    

---

### ❓ 질문 5

코드 A와 코드 B의 결과가 달라지는 핵심 이유를

“딕셔너리 객체 수정”과 “변수 재할당” 관점에서 설명하시오.

### ✅ 답변

> A코드는 age값만 변경하는 것이고
> 
> 
> B코드는 age만 변경하는 것 처럼 보이지만 key와 value값이 재할당됨
> 

🟡 **개념은 접근했으나 핵심 표현이 흐림**

### 📌 정확한 정리 (코드 기준)

```python
# 코드 A
defupdate_age(info):
	info["age"] =21

```

👉 **기존 딕셔너리 객체를 수정**

```python
# 코드 B
defupdate_age(info):
	info = {"name":"kim","age":21}

```

👉 **새 딕셔너리를 만들어 변수에 재할당**

즉,

- 코드 A: 객체 수정 → 원본 영향 O
- 코드 B: 변수 재할당 → 원본 영향 X

---

## 🔍 테스트 4-2 핵심 정리

```markdown
- 딕셔너리는 함수 인자로 전달되면 같은 객체를 참조한다
- info["key"] = value 는 원본 딕셔너리를 직접 수정한다
- info = {...} 는 새로운 딕셔너리를 만들어 재할당하는 것이다
- 객체 수정과 변수 재할당은 완전히 다른 동작이다

```

---

## 🧠 한 문장 요약

```markdown
딕셔너리를 함수에서 수정하면 원본이 바뀌지만, 새 딕셔너리를 재할당하면 원본은 바뀌지 않는다

```