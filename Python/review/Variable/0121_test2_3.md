## 🧪 테스트 2-확장③ — 전역 변수 vs return 값

---

### 🔹 코드 1 — 전역 변수 사용

```python
count =0

def increase():
    global count
    count +=1

increase()
increase()
print(count)

```

---

### ❓ 질문 1

위 코드에서 `count`의 최종 출력 값은 얼마인가?

### ✅ 답변

> 2이다.
> 

✔ **정답**

👉 `increase()` 함수가 두 번 호출되며,

전역 변수 `count`가 함수 안에서 직접 증가한다.

---

---

### 🔹 코드 2 — return 값 사용

```python
def increase(count):
    count +=1
return count

count =0
count = increase(count)
count = increase(count)
print(count)

```

---

### ❓ 질문 2

이 코드에서 `count`의 최종 출력 값은 얼마인가?

### ✅ 답변

> 2이다.
> 

✔ **정답**

👉 함수가 호출될 때마다 현재 `count` 값이 인자로 전달되고,

증가된 결과가 `return`으로 반환되어 다시 `count`에 대입된다.

---

---

### ❓ 질문 3

두 코드의 결과는 같지만, 값이 증가되는 방식에서 가장 큰 차이점은 무엇인가?

### ✅ 답변

> 첫 번째 코드는 함수 안에서 전역 변수를 직접 변경한다.
> 
> 
> 두 번째 코드는 함수 안의 지역 변수를 증가시키고, 그 결과를 반환하여 바깥에서 다시 할당한다.
> 

✔ **정답**

👉 첫 번째 방식은 **외부 상태를 직접 변경**한다.

👉 두 번째 방식은 **값을 받아 처리한 뒤 결과를 돌려준다.**

---

---

### ❓ 질문 4

두 번째 코드에서는 `global`을 사용하지 않았는데도 값이 정상적으로 증가하는 이유는 무엇인가?

### ✅ 답변

> 함수 안에서는 지역 변수를 증가시키고, 그 결과를 return으로 반환하기 때문이다.
> 

✔ **정답**

👉 `count`는 함수 안에서 지역 변수로만 사용되며,

증가된 결과를 반환받아 바깥에서 다시 `count`에 대입하기 때문에 전역 변수가 필요 없다.

---

---

### ❓ 질문 5

전역 변수보다 return 값을 사용하는 방식이 더 좋은 이유는 무엇인가?

### ✅ 답변

> 전역 변수를 사용하면 함수가 호출되는 위치에 따라 값이 예상과 다르게 변경될 수 있다.
> 

✔ **아주 좋은 답변**

👉 전역 변수는 **여러 곳에서 동시에 수정될 수 있어**

코드의 흐름을 예측하기 어렵게 만든다.

👉 return 값을 사용하는 방식은

- 입력 → 처리 → 출력 흐름이 명확하고
- 함수의 동작을 추적하기 쉽다.

---

## 📌 테스트 2-확장③ 핵심 요약 (md용)

```markdown
- 전역 변수 방식은 함수가 외부 상태를 직접 변경한다
- return 방식은 값을 받아 처리한 뒤 결과를 반환한다
- return을 사용하면 함수의 동작이 예측 가능해진다
- 전역 변수는 호출 위치나 순서에 따라 버그를 만들기 쉽다

```