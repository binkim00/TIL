## 1) “기본점수 내장함수”를 못 쓰는 이유: ‘패턴’으로 안 외워져 있어서입니다

시험에서 내장함수는 **문법을 창의적으로 쓰는 게 아니라** 보통 아래 **3~4개 패턴**으로만 등장합니다.

* 평균: `sum(lst) / len(lst)`
* 개수 세기: `sum(1 for x in lst if 조건)` (혹은 반복문 + 카운트)
* 최댓값/최솟값: `max(lst)`, `min(lst)`
* 정렬/뒤집기: `sorted(lst)`, `reversed(lst)`, `lst[::-1]`, `lst.reverse()`

**지금 제출 코드들을 보면** “내장함수 없는 버전”은 어느 정도 하실 수 있는데,
“내장함수 버전”으로 **바로 치환하는 스위치가 머릿속에 없다**가 핵심이에요.

---

## 2) 파일별로 드러난 ‘부족한 부분’ 진단

### (1) 조건 분기 설계/경계값 처리(구간 문제)

주차요금 문제에서 `if`가 전부 독립이라서(elif가 아니라서) **한 값이 여러 조건에 동시에 걸릴 수 있고**, 구간이 끊겨있습니다(예: 30~40, 40~50, 50~60 처리가 애매 / 300분 상한 10000원도 미반영).
즉 **“요금 규칙을 구간으로 정확히 쪼개는 능력 + elif/return 설계”**가 부족하다는 신호입니다. 

✅ 보완 포인트

* “구간 문제”는 거의 항상 `if / elif / else` 로 **한 번만 타게** 설계합니다.
* “상한/하한” 같은 추가 조건은 마지막에 `min(계산값, 상한)` 패턴으로 정리합니다(기본점수용).

---

### (2) “반환 타입” 감각 부족 (리스트 vs iterator vs None)

`reverse_list`에서 `reversed(result)`를 그대로 반환해서 **리스트가 아니라 iterator**가 나갑니다. 테스트 기대값은 리스트인데 타입이 달라서 오답이 나기 쉬워요. 

✅ 보완 포인트

* `reversed(x)`는 **뒤집힌 “뷰/반복자”**입니다 → 리스트가 필요하면 `list(reversed(x))`
* `lst.reverse()`는 **원본을 바꾸고 None 반환**
* `x[::-1]`는 **새 리스트 반환**

이 “3개 차이”가 시험에서 진짜 자주 나옵니다.

---

### (3) 딕셔너리 카운팅(빈도) 패턴이 아직 안 굳음

`count_menus`는 “처음 본 메뉴면 딕셔너리에 1로 넣고, 이미 있으면 +1” 패턴을 써야 하는데, 지금 코드는 `menu = orders[0]`로 값이 바뀌고, `result`에 저장 자체가 안 됩니다. 

✅ 보완 포인트(기본점수용 내장 문법 포함)

* 가장 실전적인 기본 패턴 2개만 외우면 됩니다.

  * `dict.get` 패턴: `d[x] = d.get(x, 0) + 1`
  * `setdefault` 패턴: `d.setdefault(x, 0); d[x] += 1`

여기서 막히면 “데이터 수집/가공/출력”이 계속 흔들립니다.

---

### (4) 2차원 리스트(리스트 안 리스트) 처리에서 “구조 인식”이 약함

`count_total_items`는 결과적으로 맞게 나올 수는 있는데, 문제 의도가 “총 개수/총합” 중 무엇인지에 따라 로직이 갈립니다. 지금은 **0보다 큰 원소의 ‘개수’만 세고** 있어요. 
이건 “문제 해석 → 어떤 값을 누적할지(개수/합/조건부합)” 결정하는 단계가 약하다는 신호입니다.

✅ 보완 포인트

* 2차원은 항상 머릿속에 이 3개 중 하나로 분류합니다.

  1. “원소 개수 세기”
  2. “원소 합 구하기”
  3. “행/열 단위로 가공(각 행의 max/min/sum 등)”

---

### (5) 최댓값 로직에서 “초기화 위치”와 “루프 범위” 실수

`sum_row_maximums`는 행마다 max를 구하는 문제인데, `maxnum = num` 초기화가 **내부 루프에서 계속 덮여서 사실상 마지막 값으로 시작**하게 됩니다. 

✅ 보완 포인트

* 최댓값 패턴은 “초기값 = 첫 원소”를 **행 루프 시작 시점에 한 번만** 잡아야 합니다.
* 기본점수라면 그냥 `max(row)` 로 끝내는 문제입니다.

---

### (6) 재귀 문제인데 재귀 형태 자체가 안 잡힘 + 데이터 구조 접근 실수

`categorize_books`는 `for key, value in books:` 자체가 구조가 안 맞습니다(books는 dict들의 리스트). 그리고 주석에 “반드시 재귀”라고 되어 있는데 재귀가 없습니다. 

✅ 보완 포인트

* **리스트(여러 개) 처리 재귀 템플릿**을 하나 고정으로 외워두셔야 합니다.

  * 예: “맨 앞 1개 처리 + 나머지 재귀”
* 그리고 `books[0]`은 dict이므로 `books[0]['category']` 처럼 접근해야 합니다(구조 인식).

---

### (7) “두 번째로 큰 값”은 예외 케이스(중복, 초기화, 비교) 때문에 자주 터짐

`find_second_largest`는 루프 중첩과 변수 재사용이 많아서 값이 꼬일 확률이 큽니다(특히 중복 값 있을 때). 

✅ 보완 포인트

* 기본점수라면 보통 `sorted`/`set`을 쓰는 풀이가 있습니다(문제 조건에 따라).
* 내장함수 금지 버전은 “1등/2등 변수 두 개”로 한 번에 갱신하는 패턴을 연습해야 합니다.

---

### (8) 시뮬레이션(로봇) 문제는 “방향/좌표 상태 관리” 템플릿이 필요

`robot_simulation`은 아직 구현이 비어있어서, 시뮬레이션 템플릿이 손에 안 붙은 상태로 보입니다. 

✅ 보완 포인트

* 상태는 보통 3개: `x, y, direction_index`
* 방향 배열: `dirs = [(1,0),(0,-1),(-1,0),(0,1)]` 같은 식으로 두고 회전은 인덱스로 처리

---

## 3) “지금 당장 우선순위”는 이 4개

1. **dict 빈도/누적 패턴 고정**

   * `get`, `setdefault`
2. **반환 타입(특히 reversed / sort / reverse) 구분**
3. **2차원 리스트 처리(행 단위 가공: max/sum/조건 카운트)**
4. **구간/요금/조건문 설계(elif + 경계값 + 상한/하한 처리)**

이 4개가 잡히면, “수집→가공→출력”이 훨씬 덜 흔들리고
내장함수로 기본점수도 안정적으로 챙길 수 있습니다.

---

## 4) 상황에 맞는 공부 방식 제안

이미 “내장함수 없이 구현”을 많이 하셔서 **기초 로직 근육은 있습니다.**
이제는 시험용으로 이렇게 “두 레이어”로 훈련하는 게 효율이 좋아요.

* **A레이어(기본점수용):** 내장함수/메서드로 1~3줄 풀이
* **B레이어(가산점용):** 반복문/조건문으로 직접 구현

지금은 B레이어만 강해서, 시험에서 A레이어로 스위칭이 안 되는 상태로 보입니다.

---
